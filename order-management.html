<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Order Management - Aether</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="assets/css/custom.css">
    
    <style>
        /* 주문 관리 시스템 전용 스타일 */
        .order-management-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            padding: 2rem 0;
        }
        
        .order-header {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        
        .order-stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
            border-left: 4px solid #6c757d;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            text-align: center;
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        
        .stat-card.active {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            border-left-width: 6px;
        }
        
        .stat-card.pending { border-left-color: #ffc107; }
        .stat-card.processing { border-left-color: #17a2b8; }
        .stat-card.shipping { border-left-color: #007bff; }
        .stat-card.completed { border-left-color: #28a745; }
        .stat-card.cancelled { border-left-color: #dc3545; }
        
        .stat-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: #212529;
            margin-bottom: 0.3rem;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
        }
        
        .order-filters {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            margin-bottom: 2rem;
        }
        
        /* 날짜 네비게이션 스타일 */
        .date-navigation {
            text-align: center;
            padding: 1rem 0;
        }
        
        .date-nav-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .date-nav-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #333;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .date-nav-btn:hover {
            background: #f8f9fa;
            color: #007bff;
        }
        
        .current-date-display {
            text-align: center;
        }
        
        .date-year {
            font-size: 1rem;
            color: #666;
            margin-bottom: 0.25rem;
        }
        
        .date-main {
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .date-month-day {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }
        
        .date-weekday {
            font-size: 1rem;
            color: #666;
        }
        
        .adjacent-dates {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
        }
        
        .adjacent-date {
            font-size: 0.9rem;
            color: #999;
        }
        
        /* 토스트 메시지 애니메이션 */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .order-list-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .order-item {
            border-bottom: 1px solid #e9ecef;
            padding: 1.5rem;
            transition: background-color 0.3s ease;
        }
        
        .order-item:hover {
            background-color: #f8f9fa;
        }
        
        .order-item:last-child {
            border-bottom: none;
        }
        
        .order-status {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-pending { background: #fff3cd; color: #856404; }
        .status-pending_payment { background: #fff3cd; color: #856404; }
        .status-processing { background: #d1ecf1; color: #0c5460; }
        .status-shipping { background: #cce5ff; color: #004085; }
        .status-shipped { background: #d1ecf1; color: #0c5460; }
        .status-completed { background: #d4edda; color: #155724; }
        .status-cancelled { background: #f8d7da; color: #721c24; }
        
        .order-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .btn-action {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn-view { background: #6c757d; color: white; border: none; }
        .btn-view:hover { background: #5a6268; color: white; }
        
        .btn-process { background: #17a2b8; color: white; border: none; }
        .btn-process:hover { background: #138496; color: white; }
        
        .btn-ship { background: #007bff; color: white; border: none; }
        .btn-ship:hover { background: #0056b3; color: white; }
        
        .btn-complete { background: #28a745; color: white; border: none; }
        .btn-complete:hover { background: #1e7e34; color: white; }
        
        .btn-cancel { background: #dc3545; color: white; border: none; }
        .btn-cancel:hover { background: #c82333; color: white; }
        
        /* 반품 버튼 스타일 (완료된 주문의 취소 버튼) */
        .btn-return { background: #fd7e14; color: white; }
        .btn-return:hover { background: #e55a00; color: white; }
        
        .japanese-heading {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            font-weight: 600;
            color: #212529;
        }
        
        .japanese-text {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            color: #6c757d;
        }
        
        .empty-orders {
            text-align: center;
            padding: 4rem 2rem;
            color: #6c757d;
        }
        
        .empty-orders i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
        }
        
        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3em;
        }
        
        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .order-management-container {
                padding: 1rem 0;
            }
            
            .order-header {
                padding: 1.5rem;
                margin-bottom: 1rem;
            }
            
            .order-stats-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 0.5rem;
            }
            
            .stat-card {
                padding: 0.8rem 0.5rem;
            }
            
            .stat-number {
                font-size: 1.4rem;
            }
            
            .stat-label {
                font-size: 0.65rem;
            }
            
            .order-item {
                padding: 1rem;
            }
            
            .order-actions {
                justify-content: center;
                margin-top: 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .order-stats-grid {
                gap: 0.3rem;
            }
            
            .stat-card {
                padding: 0.6rem 0.3rem;
            }
            
            .stat-number {
                font-size: 1.2rem;
            }
            
            .stat-label {
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <div class="order-management-container">
        <div class="container-fluid">
            <!-- 헤더 -->
            <div class="order-header">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <div>
                        <h1 class="japanese-heading mb-2">
                            <i class="fas fa-shopping-cart me-3"></i>注文管理システム
                        </h1>
                        <p class="japanese-text mb-0">Order Management System</p>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-outline-secondary" onclick="refreshOrders()">
                            <i class="fas fa-sync-alt me-2"></i>更新
                        </button>
                        <button class="btn btn-dark" onclick="exportOrders()">
                            <i class="fas fa-download me-2"></i>エクスポート
                        </button>
                        <a href="admin-dashboard.html" class="btn btn-outline-dark">
                            <i class="fas fa-arrow-left me-2"></i>管理ダッシュボード
                        </a>
                    </div>
                </div>
                
                <!-- 주문 통계 -->
                <div class="order-stats-grid">
                    <div class="stat-card pending" onclick="filterByStatus('pending')" data-status="pending">
                        <div class="stat-number" id="pending-count">0</div>
                        <div class="stat-label">処理待ち</div>
                    </div>
                    <div class="stat-card processing" onclick="filterByStatus('processing')" data-status="processing">
                        <div class="stat-number" id="processing-count">0</div>
                        <div class="stat-label">処理中</div>
                    </div>
                    <div class="stat-card shipping" onclick="filterByStatus('shipping')" data-status="shipping">
                        <div class="stat-number" id="shipping-count">0</div>
                        <div class="stat-label">配送中</div>
                    </div>
                    <div class="stat-card completed" onclick="filterByStatus('completed')" data-status="completed">
                        <div class="stat-number" id="completed-count">0</div>
                        <div class="stat-label">完了</div>
                    </div>
                    <div class="stat-card cancelled" onclick="filterByStatus('cancelled')" data-status="cancelled">
                        <div class="stat-number" id="cancelled-count">0</div>
                        <div class="stat-label">キャンセル</div>
                    </div>
                </div>
            </div>
            
            <!-- 필터 -->
            <div class="order-filters">
                <!-- 상단 필터 선택 필드들 -->
                <div class="row mb-4">
                    <div class="col-md-3">
                        <label class="form-label japanese-text">注文状態</label>
                        <select class="form-select" id="status-filter" onchange="filterOrders()">
                            <option value="">全て</option>
                            <option value="pending">処理待ち</option>
                            <option value="processing">処理中</option>
                            <option value="shipping">配送中</option>
                            <option value="completed">完了</option>
                            <option value="cancelled">キャンセル</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label japanese-text">期間</label>
                        <select class="form-select" id="date-filter" onchange="onDateFilterChange()">
                            <option value="today">今日</option>
                            <option value="month">今月</option>
                            <option value="year">今年</option>
                            <option value="all">全期間</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label japanese-text">検索</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="search-input" 
                                   placeholder="注文番号、顧客名で検索" onkeyup="searchOrders()">
                            <button class="btn btn-outline-secondary" onclick="clearSearch()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <label class="form-label japanese-text">&nbsp;</label>
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-secondary flex-fill" onclick="clearAllFilters()">
                                <i class="fas fa-filter me-1"></i>リセット
                            </button>
                            <button class="btn btn-outline-dark flex-fill" onclick="downloadCSV()">
                                <i class="fas fa-download me-1"></i>CSV
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 하단 날짜 네비게이션 -->
                <div class="row">
                    <div class="col-12">
                        <div class="date-navigation">
                            <div class="date-nav-container">
                                <button class="date-nav-btn" onclick="navigateDate(-1)">
                                    <i class="fas fa-chevron-left"></i>
                                </button>
                                <div class="current-date-display">
                                    <div class="date-year" id="current-year">2025年</div>
                                    <div class="date-main">
                                        <span class="date-month-day" id="current-month-day">10月2日</span>
                                        <span class="date-weekday" id="current-weekday">(金)</span>
                                    </div>
                                </div>
                                <button class="date-nav-btn" onclick="navigateDate(1)">
                                    <i class="fas fa-chevron-right"></i>
                                </button>
                            </div>
                            <div class="adjacent-dates">
                                <span class="adjacent-date" id="prev-date">2025年 10月1日 (金)</span>
                                <span class="adjacent-date" id="next-date">2025年 10月3日 (金)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 주문 목록 -->
            <div class="order-list-container">
                <div id="orders-container">
                    <div class="loading-spinner">
                        <div class="spinner-border text-secondary" role="status">
                            <span class="visually-hidden">読み込み中...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 주문 상세 모달 -->
    <div class="modal fade" id="orderDetailModal" tabindex="-1" aria-labelledby="orderDetailModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title japanese-heading" id="orderDetailModalLabel">注文詳細</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="order-detail-content">
                    <!-- 주문 상세 내용이 여기에 표시됩니다 -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
                    <button type="button" class="btn btn-dark" onclick="printOrder()">印刷</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <!-- Firebase Config -->
    <script src="assets/js/firebase-config-new.js"></script>
    
    <script>
        // 전역 변수
        let allOrders = [];
        let filteredOrders = [];
        let currentUser = null;
        let currentDate = new Date(); // 현재 선택된 날짜
        
        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 주문 관리 시스템 초기화 시작');
            
            // DOM 로드 후 약간의 지연을 두고 초기화 (Firebase 스크립트 로드 대기)
            setTimeout(() => {
            initializeOrderManagement();
            updateDateDisplay();
            }, 100);
        });
        
        // 날짜 네비게이션 함수
        function navigateDate(direction) {
            const dateFilter = document.getElementById('date-filter').value;
            
            switch(dateFilter) {
                case 'month':
                    // 월 단위로 이동 - 해당 월의 첫째 날로 설정
                    currentDate.setMonth(currentDate.getMonth() + direction);
                    currentDate.setDate(1); // 월의 첫째 날로 설정
                    break;
                case 'year':
                    // 년 단위로 이동 - 해당 년의 1월 1일로 설정
                    currentDate.setFullYear(currentDate.getFullYear() + direction);
                    currentDate.setMonth(0); // 1월
                    currentDate.setDate(1); // 1일
                    break;
                case 'today':
                default:
                    // 일 단위로 이동 (기본값)
                    currentDate.setDate(currentDate.getDate() + direction);
                    break;
            }
            
            updateDateDisplay();
            
            // 날짜 이동 후 해당 기간의 주문 표시
            console.log('🔄 날짜 이동으로 인한 재필터링:', currentDate.toLocaleDateString('ja-JP'));
            if (allOrders.length > 0) {
                if (dateFilter === 'today') {
                    // 일 단위 필터는 특정 날짜만 표시
                    applySpecificDateFilter(allOrders, currentDate);
                } else {
                    // 월/년 단위 필터는 해당 기간 전체 표시
                    applyDateFilter(allOrders, dateFilter);
                }
            } else {
                // 주문 데이터가 없으면 다시 로드
                loadOrders();
            }
        }
        
        // 날짜 표시 업데이트
        function updateDateDisplay() {
            const dateFilter = document.getElementById('date-filter').value;
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth() + 1;
            const date = currentDate.getDate();
            const weekday = currentDate.toLocaleDateString('ja-JP', { weekday: 'short' });
            
            // 현재 날짜 표시 (기간에 따라 다르게)
            document.getElementById('current-year').textContent = `${year}年`;
            
            switch(dateFilter) {
                case 'today':
                    document.getElementById('current-month-day').textContent = `${month}月${date}日`;
                    document.getElementById('current-weekday').textContent = `(${weekday})`;
                    break;
                case 'month':
                    document.getElementById('current-month-day').textContent = `${month}月`;
                    document.getElementById('current-weekday').textContent = '';
                    break;
                case 'year':
                    document.getElementById('current-month-day').textContent = `${year}年`;
                    document.getElementById('current-weekday').textContent = '';
                    break;
                default:
                    document.getElementById('current-month-day').textContent = `${month}月${date}日`;
                    document.getElementById('current-weekday').textContent = `(${weekday})`;
                    break;
            }
            
            // 이전/다음 날짜 표시 (기간에 따라 다르게)
            const prevDate = new Date(currentDate);
            const nextDate = new Date(currentDate);
            
            switch(dateFilter) {
                case 'today':
                    prevDate.setDate(currentDate.getDate() - 1);
                    nextDate.setDate(currentDate.getDate() + 1);
                    break;
                case 'month':
                    prevDate.setMonth(currentDate.getMonth() - 1);
                    nextDate.setMonth(currentDate.getMonth() + 1);
                    break;
                case 'year':
                    prevDate.setFullYear(currentDate.getFullYear() - 1);
                    nextDate.setFullYear(currentDate.getFullYear() + 1);
                    break;
                default:
                    prevDate.setDate(currentDate.getDate() - 1);
                    nextDate.setDate(currentDate.getDate() + 1);
                    break;
            }
            
            const formatAdjacentDate = (date, filter) => {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const weekday = date.toLocaleDateString('ja-JP', { weekday: 'short' });
                
                switch(filter) {
                    case 'today':
                        return `${year}年 ${month}月${day}日 (${weekday})`;
                    case 'month':
                        return `${year}年 ${month}月`;
                    case 'year':
                        return `${year}年`;
                    default:
                        return `${year}年 ${month}月${day}日 (${weekday})`;
                }
            };
            
            document.getElementById('prev-date').textContent = formatAdjacentDate(prevDate, dateFilter);
            document.getElementById('next-date').textContent = formatAdjacentDate(nextDate, dateFilter);
        }
        
        // 기간 필터 변경 시 호출되는 함수
        function onDateFilterChange() {
            const dateFilter = document.getElementById('date-filter').value;
            
            // 기간에 따라 현재 날짜를 적절히 설정
            const now = new Date();
            
            switch(dateFilter) {
                case 'today':
                    // 오늘 날짜로 설정
                    currentDate = new Date(now);
                    break;
                case 'month':
                    // 이번 달 1일로 설정
                    currentDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                case 'year':
                    // 올해 1월 1일로 설정
                    currentDate = new Date(now.getFullYear(), 0, 1);
                    break;
                case 'all':
                    // 전체 기간이므로 날짜 네비게이션 숨기기
                    document.querySelector('.date-navigation').style.display = 'none';
                    filterOrders();
                    return;
            }
            
            // 날짜 네비게이션 표시
            document.querySelector('.date-navigation').style.display = 'block';
            
            // 날짜 표시 업데이트
            updateDateDisplay();
            
            // 기존 주문 데이터에 새로운 날짜 필터 적용
            console.log('🔄 날짜 필터 변경으로 인한 재필터링:', dateFilter);
            if (allOrders.length > 0) {
                if (dateFilter === 'today') {
                    // 오늘 필터 선택 시 currentDate를 오늘로 설정
                    currentDate = new Date();
                    updateDateDisplay();
                }
                applyDateFilter(allOrders, dateFilter);
            } else {
                // 주문 데이터가 없으면 다시 로드
                loadOrders();
            }
        }
        
        // 주문 관리 시스템 초기화
        function initializeOrderManagement() {
            console.log('🔍 주문 관리 시스템 초기화 시작');
            
            // Firebase 초기화 상태 확인 함수
            function checkFirebaseAndLoad() {
                console.log('🔍 Firebase 초기화 상태 확인 중...');
                
                // 여러 방법으로 Firebase 상태 확인
                let isFirebaseReady = false;
                
                // 방법 1: window.FirebaseService 확인 (더 정확한 확인)
                if (window.FirebaseService && window.FirebaseService.db && window.FirebaseService.db.collection) {
                    console.log('✅ FirebaseService.db 사용 가능');
                    isFirebaseReady = true;
                }
                // 방법 2: window.db 확인 (더 정확한 확인)
                else if (window.db && window.db.collection) {
                    console.log('✅ window.db 사용 가능');
                    isFirebaseReady = true;
                }
                // 방법 3: firebase.apps 확인
                else if (typeof firebase !== 'undefined' && firebase.apps && firebase.apps.length > 0) {
                    console.log('✅ firebase.apps 사용 가능');
                // FirebaseService 인스턴스 생성
                    if (window.FirebaseService) {
                    const firebaseService = new window.FirebaseService();
                    window.FirebaseService.db = firebaseService.db;
                    console.log('✅ FirebaseService 인스턴스 생성 완료');
                        isFirebaseReady = true;
                    }
                }
                
                if (isFirebaseReady) {
                    console.log('🎉 Firebase 준비 완료, 주문 데이터 로드 시작');
                setTimeout(() => {
                    loadOrders();
                    }, 300);
                } else {
                    console.log('⏳ Firebase 초기화 대기 중...');
                    console.log('🔍 Firebase 상태 디버깅:', {
                        FirebaseService: !!window.FirebaseService,
                        FirebaseServiceDb: !!window.FirebaseService?.db,
                        FirebaseServiceDbCollection: !!window.FirebaseService?.db?.collection,
                        windowDb: !!window.db,
                        windowDbCollection: !!window.db?.collection,
                        firebaseApps: !!(typeof firebase !== 'undefined' && firebase.apps && firebase.apps.length > 0)
                    });
                    
                    // 더 긴 대기 시간으로 설정 (Firebase 초기화 완료 대기)
                    setTimeout(checkFirebaseAndLoad, 2000);
                }
                
                return isFirebaseReady;
            }
            
            // 즉시 확인 시도
            if (!checkFirebaseAndLoad()) {
                // Firebase 초기화 이벤트 리스너 등록
                window.addEventListener('firebaseInitialized', function(event) {
                    console.log('🎉 Firebase 초기화 이벤트 수신:', event.detail);
                    // 이벤트 수신 후 잠시 대기 후 확인
            setTimeout(() => {
                        checkFirebaseAndLoad();
                    }, 1000);
                });
                
                // 추가: Firebase 객체 직접 감시
                const watchFirebase = () => {
                    if (window.FirebaseService && window.FirebaseService.db && window.FirebaseService.db.collection) {
                        console.log('🎉 Firebase 객체 직접 감지 완료');
                        checkFirebaseAndLoad();
                } else {
                        setTimeout(watchFirebase, 1000);
                    }
                };
                watchFirebase();
                
                // 백업: 주기적 확인 (최대 30초)
                let attempts = 0;
                const maxAttempts = 60; // 30초 (500ms * 60)
                
                const checkInterval = setInterval(() => {
                    attempts++;
                    console.log(`🔄 Firebase 상태 확인 시도 ${attempts}/${maxAttempts}`);
                    
                    if (checkFirebaseAndLoad() || attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        if (attempts >= maxAttempts) {
                            console.error('❌ Firebase 초기화 시간 초과');
                            showError('Firebase 초기화에 실패했습니다. 페이지를 새로고침해주세요.');
                            
                            // 재시도 버튼 추가
                            const retryButton = document.createElement('button');
                            retryButton.className = 'btn btn-secondary mt-2';
                            retryButton.innerHTML = '🔄 재시도';
                            retryButton.onclick = () => {
                                window.location.reload();
                            };
                            
                            const errorContainer = document.getElementById('error-container');
                            if (errorContainer) {
                                errorContainer.appendChild(retryButton);
                            }
                        }
                    }
                }, 500);
            }
        }
        
        // 주문 데이터 로드
        function loadOrders() {
            console.log('📊 Firebase에서 주문 데이터 로드 시작');
            
            // 여러 방법으로 Firestore 인스턴스 확인
            let db = null;
            
            if (window.FirebaseService && window.FirebaseService.db && window.FirebaseService.db.collection) {
                db = window.FirebaseService.db;
                console.log('✅ FirebaseService.db 사용');
            } else if (window.db && window.db.collection) {
                db = window.db;
                console.log('✅ window.db 사용');
            } else {
                console.error('❌ Firestore 인스턴스를 찾을 수 없습니다.');
                console.log('🔍 사용 가능한 객체들:');
                console.log('- window.FirebaseService:', typeof window.FirebaseService);
                console.log('- window.FirebaseService.db:', typeof window.FirebaseService?.db);
                console.log('- window.FirebaseService.db.collection:', typeof window.FirebaseService?.db?.collection);
                console.log('- window.db:', typeof window.db);
                console.log('- window.db.collection:', typeof window.db?.collection);
                
                // Firebase 대기 후 재시도
                console.log('⏳ Firebase 초기화 대기 후 재시도...');
                setTimeout(() => {
                    console.log('🔄 loadOrders 재시도');
                    loadOrders();
                }, 3000);
                return;
            }
            
            const ordersRef = db.collection('orders');
            console.log('📋 orders 컬렉션 참조 생성 완료');
            
            // 현재 날짜 필터 값 가져오기
            const dateFilter = document.getElementById('date-filter')?.value || 'today';
            console.log('📅 적용할 날짜 필터:', dateFilter);
            
            // 모든 주문을 로드한 후 클라이언트 사이드에서 필터링
            let query = ordersRef;
            
            // orderBy를 위한 필드 결정 (여러 필드 시도)
            let orderByField = 'orderDate';
            try {
                query = query.orderBy('orderDate', 'desc');
            } catch (error) {
                console.log('⚠️ orderDate로 정렬 실패, createdAt 시도:', error);
                orderByField = 'createdAt';
                query = query.orderBy('createdAt', 'desc');
            }
            
            console.log('📅 정렬 필드:', orderByField);
            
            query.get()
                .then((querySnapshot) => {
                    allOrders = [];
                    console.log('📋 Firestore 쿼리 결과:', querySnapshot.size, '개 문서');
                    
                    // 첫 번째 문서의 구조 확인 (디버깅용)
                    if (querySnapshot.size > 0) {
                        const firstDoc = querySnapshot.docs[0];
                        console.log('🔍 첫 번째 주문 문서 구조:', firstDoc.data());
                        console.log('🔍 주문 날짜 필드들:', {
                            orderDate: firstDoc.data().orderDate,
                            createdAt: firstDoc.data().createdAt,
                            timestamp: firstDoc.data().timestamp
                        });
                    }
                    
                    querySnapshot.forEach((doc) => {
                        const orderData = doc.data();
                        orderData.id = doc.id;
                        console.log('📄 주문 데이터:', doc.id, orderData);
                        allOrders.push(orderData);
                    });
                    
                    // 날짜별로 다시 정렬 (최신순)
                    allOrders.sort((a, b) => {
                        const dateA = new Date(a.orderDate || a.createdAt || 0);
                        const dateB = new Date(b.orderDate || b.createdAt || 0);
                        return dateB - dateA;
                    });
                    
                    console.log('✅ 주문 데이터 로드 완료:', allOrders.length, '개 (최신순 정렬)');
                    
                    if (allOrders.length === 0) {
                        console.log('⚠️ 주문 데이터가 없습니다. Firebase 콘솔에서 orders 컬렉션을 확인해주세요.');
                        showEmptyState();
                    } else {
                        // 클라이언트 사이드에서 날짜 필터링 적용
                        console.log('🔍 클라이언트 사이드 날짜 필터링 시작:', dateFilter);
                        applyDateFilter(allOrders, dateFilter);
                    }
                })
                .catch((error) => {
                    console.error('❌ 주문 데이터 로드 실패:', error);
                    
                    // 날짜 필터 쿼리 실패 시 전체 주문 로드 시도
                    if (dateFilter !== 'all') {
                        console.log('🔄 날짜 필터 실패, 전체 주문 로드 시도');
                        ordersRef.orderBy('orderDate', 'desc').get()
                            .then((querySnapshot) => {
                                allOrders = [];
                                console.log('📋 전체 주문 쿼리 결과:', querySnapshot.size, '개 문서');
                                
                                querySnapshot.forEach((doc) => {
                                    const orderData = doc.data();
                                    orderData.id = doc.id;
                                    console.log('📄 전체 주문 데이터:', doc.id, orderData);
                                    allOrders.push(orderData);
                                });
                                
                                console.log('✅ 전체 주문 데이터 로드 완료:', allOrders.length, '개 (최신순 정렬)');
                                
                                if (allOrders.length === 0) {
                                    console.log('⚠️ 주문 데이터가 없습니다. Firebase 콘솔에서 orders 컬렉션을 확인해주세요.');
                                }
                                
                                displayOrders();
                            })
                            .catch((fallbackError) => {
                                console.error('❌ 전체 주문 로드도 실패:', fallbackError);
                                showError('주문 데이터를 불러오는데 실패했습니다: ' + fallbackError.message);
                            });
                    } else {
                    showError('주문 데이터를 불러오는데 실패했습니다: ' + error.message);
                    }
                });
        }
        
        // 클라이언트 사이드 날짜 필터링 함수
        function applyDateFilter(orders, dateFilter) {
            console.log('🔍 날짜 필터링 적용:', dateFilter, '주문 수:', orders.length);
            
            if (dateFilter === 'all') {
                // 전체 기간 - 모든 주문 표시
                filteredOrders = [...orders];
                console.log('📅 전체 기간 필터 적용:', filteredOrders.length, '개 주문');
            } else {
                const now = new Date();
                filteredOrders = orders.filter(order => {
                    // 주문 날짜 추출 (여러 필드 시도)
                    let orderDate = null;
                    
                    if (order.orderDate) {
                        if (order.orderDate.toDate && typeof order.orderDate.toDate === 'function') {
                            orderDate = order.orderDate.toDate();
                        } else if (order.orderDate.seconds) {
                            orderDate = new Date(order.orderDate.seconds * 1000);
                        } else {
                            orderDate = new Date(order.orderDate);
                        }
                    } else if (order.createdAt) {
                        if (order.createdAt.toDate && typeof order.createdAt.toDate === 'function') {
                            orderDate = order.createdAt.toDate();
                        } else if (order.createdAt.seconds) {
                            orderDate = new Date(order.createdAt.seconds * 1000);
                        } else {
                            orderDate = new Date(order.createdAt);
                        }
                    } else if (order.timestamp) {
                        orderDate = new Date(order.timestamp);
                    }
                    
                    if (!orderDate || isNaN(orderDate.getTime())) {
                        console.log('⚠️ 날짜를 찾을 수 없는 주문:', order.id);
                        return false;
                    }
                    
                    switch(dateFilter) {
                        case 'today':
                            // 오늘 - currentDate 사용 (날짜 네비게이션과 일치)
                            return orderDate.toDateString() === currentDate.toDateString();
                            
                        case 'month':
                            // 선택된 달 - currentDate 기준
                            return orderDate.getFullYear() === currentDate.getFullYear() && 
                                   orderDate.getMonth() === currentDate.getMonth();
                            
                        case 'year':
                            // 선택된 년 - currentDate 기준
                            return orderDate.getFullYear() === currentDate.getFullYear();
                            
                        default:
                            return true;
                    }
                });
                
                console.log('📅 날짜 필터링 결과:', dateFilter, '→', filteredOrders.length, '개 주문');
            }
            
            updateOrderStatistics();
            displayOrders();
        }
        
        // 특정 날짜 필터링 함수 (날짜 네비게이션용)
        function applySpecificDateFilter(orders, targetDate) {
            console.log('🔍 특정 날짜 필터링 적용:', targetDate.toLocaleDateString('ja-JP'), '주문 수:', orders.length);
            
            const startOfDay = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
            const endOfDay = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate() + 1);
            
            filteredOrders = orders.filter(order => {
                // 주문 날짜 추출 (여러 필드 시도)
                let orderDate = null;
                
                if (order.orderDate) {
                    if (order.orderDate.toDate && typeof order.orderDate.toDate === 'function') {
                        orderDate = order.orderDate.toDate();
                    } else if (order.orderDate.seconds) {
                        orderDate = new Date(order.orderDate.seconds * 1000);
                    } else {
                        orderDate = new Date(order.orderDate);
                    }
                } else if (order.createdAt) {
                    if (order.createdAt.toDate && typeof order.createdAt.toDate === 'function') {
                        orderDate = order.createdAt.toDate();
                    } else if (order.createdAt.seconds) {
                        orderDate = new Date(order.createdAt.seconds * 1000);
                    } else {
                        orderDate = new Date(order.createdAt);
                    }
                } else if (order.timestamp) {
                    orderDate = new Date(order.timestamp);
                }
                
                if (!orderDate || isNaN(orderDate.getTime())) {
                    console.log('⚠️ 날짜를 찾을 수 없는 주문:', order.id);
                    return false;
                }
                
                // 해당 날짜 범위 내에 있는지 확인
                return orderDate >= startOfDay && orderDate < endOfDay;
            });
            
            console.log('📅 특정 날짜 필터링 결과:', targetDate.toLocaleDateString('ja-JP'), '→', filteredOrders.length, '개 주문');
            
            updateOrderStatistics();
            displayOrders();
        }
        
        // 빈 상태 표시
        function showEmptyState() {
            const container = document.getElementById('orders-container');
            container.innerHTML = `
                <div class="empty-orders">
                    <i class="fas fa-shopping-cart"></i>
                    <h4 class="japanese-heading">注文データがありません</h4>
                    <p class="japanese-text">Firebase Firestoreのordersコレクションにデータがありません。</p>
                    <p class="japanese-text">テスト用の注文データを作成しますか？</p>
                    <button class="btn btn-secondary" onclick="createTestOrders()">
                        <i class="fas fa-plus me-2"></i>テスト注文を作成
                    </button>
                </div>
            `;
        }
        
        // 테스트 주문 생성
        function createTestOrders() {
            if (!confirm('テスト用の注文データを作成しますか？')) {
                return;
            }
            
            const testOrders = [
                {
                    orderDate: new Date().toISOString(),
                    status: 'pending',
                    items: [
                        { name: 'LALARECIPE BAKUCHINOL EYE CREAM', quantity: 1, price: 2980 },
                        { name: 'YUZU VITA C CREAM', quantity: 2, price: 3500 }
                    ],
                    totalAmount: 9980,
                    customer: { 
                        name: '田中太郎', 
                        email: 'tanaka@example.com', 
                        phone: '090-1234-5678' 
                    },
                    shippingAddress: {
                        name: '田中太郎',
                        address: '東京都渋谷区恵比寿1-2-3',
                        phone: '090-1234-5678'
                    }
                },
                {
                    orderDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                    status: 'processing',
                    items: [
                        { name: 'COSCELL GREEN PAPAYA PDRN PORE AMPOULE', quantity: 1, price: 4200 }
                    ],
                    totalAmount: 4200,
                    customer: { 
                        name: '佐藤花子', 
                        email: 'sato@example.com', 
                        phone: '090-2345-6789' 
                    },
                    shippingAddress: {
                        name: '佐藤花子',
                        address: '大阪府大阪市北区梅田1-1-1',
                        phone: '090-2345-6789'
                    }
                },
                {
                    orderDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'shipping',
                    items: [
                        { name: 'LUCINDE RETINOL VOLUME EYEBAG CREAM', quantity: 1, price: 3800 },
                        { name: 'MAKE HEAL GREEN PAPAYA PDRN PORE AMPOULE', quantity: 1, price: 4500 }
                    ],
                    totalAmount: 8300,
                    customer: { 
                        name: '鈴木一郎', 
                        email: 'suzuki@example.com', 
                        phone: '090-3456-7890' 
                    },
                    shippingAddress: {
                        name: '鈴木一郎',
                        address: '神奈川県横浜市西区みなとみらい2-2-2',
                        phone: '090-3456-7890'
                    }
                }
            ];
            
            console.log('📝 테스트 주문 데이터 생성 중...');
            
            // Firebase에 테스트 주문 추가
            const batch = window.FirebaseService.db.batch();
            testOrders.forEach((order, index) => {
                const docRef = window.FirebaseService.db.collection('orders').doc();
                batch.set(docRef, order);
            });
            
            batch.commit()
                .then(() => {
                    console.log('✅ 테스트 주문 데이터 생성 완료');
                    showSuccess('テスト注文データが作成されました。');
                    // 데이터 다시 로드
                    loadOrders();
                })
                .catch((error) => {
                    console.error('❌ 테스트 주문 생성 실패:', error);
                    showError('テスト注文データの作成に失敗しました。');
                });
        }
        
        // 주문 통계 업데이트
        function updateOrderStatistics() {
            const stats = {
                pending: 0,
                pending_payment: 0,
                processing: 0,
                shipping: 0,
                shipped: 0,
                completed: 0,
                cancelled: 0
            };
            
            allOrders.forEach(order => {
                if (stats.hasOwnProperty(order.status)) {
                    stats[order.status]++;
                }
            });
            
            // pending과 pending_payment를 합쳐서 표시
            document.getElementById('pending-count').textContent = stats.pending + stats.pending_payment;
            document.getElementById('processing-count').textContent = stats.processing;
            document.getElementById('shipping-count').textContent = stats.shipping;
            document.getElementById('completed-count').textContent = stats.completed;
            document.getElementById('cancelled-count').textContent = stats.cancelled;
        }
        
        // 통계 카드 클릭으로 필터링
        function filterByStatus(status) {
            console.log('📊 통계 카드 클릭:', status);
            
            // 모든 통계 카드에서 active 클래스 제거
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active');
            });
            
            // 클릭된 카드에 active 클래스 추가
            const clickedCard = document.querySelector(`[data-status="${status}"]`);
            if (clickedCard) {
                clickedCard.classList.add('active');
                console.log('✅ 활성 카드 설정:', status);
            }
            
            // 상태 필터 설정
            document.getElementById('status-filter').value = status;
            
            // 필터링 적용
            filterOrders();
            
            console.log('🔍 필터링 적용 완료');
        }
        
        // 주문 목록 표시
        function displayOrders() {
            console.log('🔄 displayOrders 함수 호출됨');
            console.log('🔍 표시할 주문 수:', filteredOrders.length);
            
            const container = document.getElementById('orders-container');
            
            if (filteredOrders.length === 0) {
                container.innerHTML = `
                    <div class="empty-orders">
                        <i class="fas fa-shopping-cart"></i>
                        <h4 class="japanese-heading">注文がありません</h4>
                        <p class="japanese-text">条件に一致する注文が見つかりませんでした。</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            filteredOrders.forEach(order => {
                console.log(`🔍 주문 ${order.id} 상태: ${order.status} → 버튼 생성 중`);
                html += createOrderItemHTML(order);
            });
            
            container.innerHTML = html;
            console.log('✅ displayOrders 완료 - DOM 업데이트됨');
        }
        
        // 주문 아이템 HTML 생성
        function createOrderItemHTML(order) {
            // 날짜 처리 - 여러 필드에서 날짜 찾기 (날짜 + 시간)
            let orderDate = '날짜 없음';
            if (order.orderDate) {
                const date = new Date(order.orderDate.seconds ? order.orderDate.seconds * 1000 : order.orderDate);
                if (!isNaN(date.getTime())) {
                    orderDate = date.toLocaleDateString('ja-JP') + ' ' + date.toLocaleTimeString('ja-JP', {hour: '2-digit', minute: '2-digit'});
                }
            } else if (order.createdAt) {
                const date = new Date(order.createdAt.seconds ? order.createdAt.seconds * 1000 : order.createdAt);
                if (!isNaN(date.getTime())) {
                    orderDate = date.toLocaleDateString('ja-JP') + ' ' + date.toLocaleTimeString('ja-JP', {hour: '2-digit', minute: '2-digit'});
                }
            }
            
            // 금액 정보 처리
            const subtotal = order.subtotal || order.originalAmount || 0;
            const shippingFee = order.shippingFee || order.shipping?.shippingFee || 0;
            const usedPoints = order.usedPoints || order.pointDiscount || 0;
            const totalAmount = order.totalAmount || 0;
            
            // 고객 이름 처리 - shipping.name 우선, 여러 필드에서 이름 찾기
            let customerName = '不明';
            if (order.shipping && order.shipping.name && order.shipping.name !== 'null') {
                customerName = order.shipping.name;
            } else if (order.customer && order.customer.name && order.customer.name !== 'null') {
                customerName = order.customer.name;
            } else if (order.userName && order.userName !== 'null') {
                customerName = order.userName;
            } else if (order.customerName && order.customerName !== 'null') {
                customerName = order.customerName;
            }
            
            const customerEmail = order.customer ? order.customer.email : (order.customerEmail || order.userEmail || '');
            
            // 배송 주소 처리
            let shippingAddress = '';
            if (order.shipping) {
                const parts = [];
                if (order.shipping.prefecture) parts.push(order.shipping.prefecture);
                if (order.shipping.city) parts.push(order.shipping.city);
                if (order.shipping.address1) parts.push(order.shipping.address1);
                if (order.shipping.address2) parts.push(order.shipping.address2);
                shippingAddress = parts.join(' ');
            }
            
            // 결제 방법 처리
            let paymentMethod = '不明';
            if (order.paymentMethod) {
                paymentMethod = order.paymentMethod === 'card' ? 'カード' : 
                               order.paymentMethod === 'bank-transfer' ? '銀行振込' : order.paymentMethod;
            } else if (order.payment && order.payment.method) {
                paymentMethod = order.payment.method === 'card' ? 'カード' : 
                               order.payment.method === 'bank-transfer' ? '銀行振込' : order.payment.method;
            }
            
            return `
                <div class="order-item">
                    <div class="row align-items-center">
                        <div class="col-md-2">
                            <div class="fw-bold">${order.id}</div>
                            <small class="text-muted">${orderDate}</small>
                        </div>
                        <div class="col-md-2">
                            <div class="fw-bold">${customerName}</div>
                            <small class="text-muted">${customerEmail}</small>
                            ${shippingAddress ? `<br><small class="text-muted">${shippingAddress}</small>` : ''}
                        </div>
                        <div class="col-md-2">
                            <span class="order-status status-${order.status}">
                                ${getStatusText(order.status)}
                            </span>
                        </div>
                        <div class="col-md-2">
                            <div class="fw-bold">¥${totalAmount.toLocaleString()}</div>
                            <small class="text-muted">商品: ¥${subtotal.toLocaleString()}</small>
                            ${shippingFee > 0 ? `<br><small class="text-muted">配送: ¥${shippingFee.toLocaleString()}</small>` : ''}
                            ${usedPoints > 0 ? `<br><small class="text-muted">ポイント: -¥${usedPoints.toLocaleString()}</small>` : ''}
                            <br><small class="text-muted">${paymentMethod}</small>
                        </div>
                        <div class="col-md-4">
                            <div class="order-actions">
                                <button class="btn btn-action btn-view" onclick="viewOrderDetail('${order.id}')">
                                    <i class="fas fa-eye me-1"></i>詳細
                                </button>
                                ${getActionButtons(order.status, order.id)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 상태별 액션 버튼 생성
        function getActionButtons(status, orderId) {
            let buttons = '';
            
            // 상태별 메인 액션 버튼
            switch(status) {
                case 'pending':
                case 'pending_payment':
                    buttons += `
                        <button class="btn btn-action btn-process" onclick="updateOrderStatus('${orderId}', 'processing')">
                            <i class="fas fa-check me-1"></i>処理開始
                        </button>
                    `;
                    break;
                case 'processing':
                    buttons += `
                        <button class="btn btn-action btn-ship" onclick="updateOrderStatus('${orderId}', 'shipping')">
                            <i class="fas fa-truck me-1"></i>配送開始
                        </button>
                    `;
                    break;
                case 'shipping':
                case 'shipped':
                    buttons += `
                        <button class="btn btn-action btn-complete" onclick="updateOrderStatus('${orderId}', 'completed')">
                            <i class="fas fa-check-circle me-1"></i>完了
                        </button>
                    `;
                    break;
                case 'completed':
                    buttons += `<span class="text-muted">完了済み</span>`;
                    break;
                case 'cancelled':
                    buttons += `<span class="text-muted">キャンセル済み</span>`;
                    break;
            }
            
            // 모든 상태에서 취소 버튼 표시 (반품 처리 포함)
            if (status !== 'cancelled') {
                // 완료된 주문의 경우 반품으로 표시
                const cancelText = status === 'completed' ? '返品' : 'キャンセル';
                const cancelIcon = status === 'completed' ? 'fa-undo' : 'fa-times';
                const cancelClass = status === 'completed' ? 'btn btn-action btn-cancel btn-return' : 'btn btn-action btn-cancel';
                
                buttons += `
                    <button class="${cancelClass}" onclick="showCancelReasonModal('${orderId}')">
                        <i class="fas ${cancelIcon} me-1"></i>${cancelText}
                    </button>
                `;
            }
            
            return buttons;
        }
        
        // 상태 텍스트 변환
        function getStatusText(status) {
            const statusMap = {
                'pending': '処理待ち',
                'pending_payment': '支払い待ち',
                'processing': '処理中',
                'shipping': '配送中',
                'shipped': '配送完了',
                'completed': '完了',
                'cancelled': 'キャンセル'
            };
            return statusMap[status] || status;
        }
        
        // 취소 사유 모달 표시
        function showCancelReasonModal(orderId) {
            // 모달 HTML 생성
            const modalHtml = `
                <div class="modal fade" id="cancelReasonModal" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">注文キャンセル理由の選択</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="mb-3">
                                    <label for="cancelReason" class="form-label">キャンセル理由を選択してください:</label>
                                    <select class="form-select" id="cancelReason">
                                        <option value="">キャンセル理由を選択してください</option>
                                        <option value="お客様都合">お客様都合</option>
                                        <option value="入金未確認">入金未確認</option>
                                        <option value="在庫不足">在庫不足</option>
                                        <option value="配送不可地域">配送不可地域</option>
                                        <option value="商品不良">商品不良</option>
                                        <option value="お客様からの要望">お客様からの要望</option>
                                        <option value="システムエラー">システムエラー</option>
                                        <option value="その他">その他</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="cancelMemo" class="form-label">追加メモ (任意):</label>
                                    <textarea class="form-control" id="cancelMemo" rows="3" placeholder="キャンセルに関する追加理由やメモを入力してください"></textarea>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
                                <button type="button" class="btn btn-danger" onclick="confirmCancel('${orderId}')">注文キャンセル</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // 기존 모달 제거
            const existingModal = document.getElementById('cancelReasonModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // 새 모달 추가
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 모달 표시
            const modal = new bootstrap.Modal(document.getElementById('cancelReasonModal'));
            modal.show();
            
            // 모달이 닫힐 때 제거
            document.getElementById('cancelReasonModal').addEventListener('hidden.bs.modal', function() {
                this.remove();
            });
        }
        
        // 취소 확인
        function confirmCancel(orderId) {
            const cancelReason = document.getElementById('cancelReason').value;
            const cancelMemo = document.getElementById('cancelMemo').value;
            
            if (!cancelReason) {
                alert('キャンセル理由を選択してください。');
                return;
            }
            
            const fullReason = cancelMemo ? `${cancelReason} - ${cancelMemo}` : cancelReason;
            updateOrderStatus(orderId, 'cancelled', fullReason);
            
            // 모달 닫기
            const modal = bootstrap.Modal.getInstance(document.getElementById('cancelReasonModal'));
            modal.hide();
        }
        
        // 주문 상태 업데이트 (취소 사유 포함)
        async function updateOrderStatus(orderId, newStatus, cancelReason = null) {
            if (!cancelReason && newStatus !== 'cancelled') {
            if (!confirm('注文状態を変更しますか？')) {
                return;
                }
            }
            
            if (!window.FirebaseService || !window.FirebaseService.db) {
                console.error('❌ FirebaseService를 찾을 수 없습니다.');
                showError('Firebase 연결에 문제가 발생했습니다.');
                return;
            }
            
            const orderRef = window.FirebaseService.db.collection('orders').doc(orderId);
            
            // 배송 시작인 경우 모달만 표시하고 상태 업데이트는 하지 않음
            if (newStatus === 'shipping') {
                console.log('🚚 배송 시작 모달 표시:', orderId);
                showShippingModal(orderId);
                return; // 상태 업데이트 없이 모달만 표시
            }
            
            try {
                await orderRef.update({
                status: newStatus,
                updatedAt: new Date().toISOString()
                });
                
                console.log('✅ 주문 상태 업데이트 완료:', orderId, newStatus);
                
                // 배송 완료 시 포인트 부여
                if (newStatus === 'delivered' || newStatus === 'completed') {
                    console.log('📦 배송 완료 - 포인트 부여 시작');
                    const pointResult = await window.FirebaseService_awardPointsOnDelivery(orderId);
                    
                    if (pointResult.success) {
                        console.log('✅ 배송 완료 포인트 부여 성공:', pointResult.pointsEarned);
                        showSuccess(`注文完了！${pointResult.pointsEarned || 0}ポイントが付与されました。`);
                    } else {
                        console.error('❌ 배송 완료 포인트 부여 실패:', pointResult.error);
                        showError('포인트 부여에 실패했습니다: ' + pointResult.message);
                    }
                }
                
                // 로컬 데이터 업데이트
                const orderIndex = allOrders.findIndex(order => order.id === orderId);
                if (orderIndex !== -1) {
                    allOrders[orderIndex].status = newStatus;
                    updateOrderStatistics();
                    displayOrders();
                }
                
                    // 이메일 알림 발송
                sendOrderStatusNotification(orderId, newStatus, cancelReason);
                
                if (newStatus !== 'delivered' && newStatus !== 'completed') {
                showSuccess('注文状態が更新されました。');
                }
                
            } catch (error) {
                console.error('❌ 주문 상태 업데이트 실패:', error);
                showError('注文状態の更新に失敗しました。');
            }
        }

        // 배송 번호 입력 모달 표시
        function showShippingModal(orderId) {
            console.log('🚚 배송 모달 표시 시작:', orderId);
            const order = allOrders.find(o => o.id === orderId);
            if (!order) {
                console.error('❌ 주문을 찾을 수 없습니다:', orderId);
                return;
            }
            console.log('✅ 주문 정보 확인:', order);

            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.id = 'shippingModal';
            modal.innerHTML = `
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">配送情報入力</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="trackingNumber" class="form-label">配送追跡番号</label>
                                <input type="text" class="form-control" id="trackingNumber" placeholder="配送追跡番号を入力してください">
                            </div>
                            <div class="mb-3">
                                <label for="shippingCompany" class="form-label">配送方法</label>
                                <select class="form-select" id="shippingCompany">
                                    <option value="yamato">ヤマト運輸 (宅急便)</option>
                                    <option value="yamato-cool">ヤマト運輸 (クール宅急便)</option>
                                    <option value="yamato-takkyubin">ヤマト運輸 (タイム便)</option>
                                    <option value="sagawa">佐川急便 (飛脚宅配便)</option>
                                    <option value="sagawa-cool">佐川急便 (飛脚宅配便クール)</option>
                                    <option value="japan-post-yu-pack">日本郵便 (ゆうパック)</option>
                                    <option value="japan-post-express">日本郵便 (EMS)</option>
                                    <option value="japan-post-registered">日本郵便 (レターパック)</option>
                                    <option value="kuroneko">クロネコヤマト</option>
                                    <option value="other">その他</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <div class="form-text">
                                    <small class="text-muted">
                                        <i class="fas fa-info-circle me-1"></i>
                                        配送方法と追跡番号は顧客にメールで通知されます。
                                    </small>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="cancelShipping('${orderId}')">キャンセル</button>
                            <button type="button" class="btn btn-dark" onclick="confirmShipping('${orderId}')">配送開始</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Bootstrap 모달 초기화 및 표시
            setTimeout(() => {
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
                // 입력 필드 초기화
                document.getElementById('trackingNumber').value = '';
                document.getElementById('shippingCompany').value = 'yamato'; // 기본값 설정
                
                console.log('✅ 배송 모달 표시 완료');
            }, 100);
            
            // 모달이 닫힐 때 제거 (상태 복원은 confirmShipping에서만 처리)
            modal.addEventListener('hidden.bs.modal', () => {
                console.log('🚚 배송 모달 닫힘');
                document.body.removeChild(modal);
            });
        }

        // 배송 시작 캔슬
        function cancelShipping(orderId) {
            console.log('🚚 배송 시작 캔슬:', orderId);
            
            // 모달 닫기
            const modal = bootstrap.Modal.getInstance(document.getElementById('shippingModal'));
            modal.hide();
            
            // 상태를 원래대로 복원 (shipping → processing)
            const orderIndex = allOrders.findIndex(o => o.id === orderId);
            if (orderIndex !== -1) {
                allOrders[orderIndex].status = 'processing';
                updateOrderStatistics();
                displayOrders();
                console.log('🔄 주문 상태 복원: shipping → processing');
            }
            
            showInfo('配送開始がキャンセルされました。');
        }

        // 배송 시작 확인
        function confirmShipping(orderId) {
            console.log('🚚 confirmShipping 함수 호출됨:', orderId);
            
            const trackingNumber = document.getElementById('trackingNumber').value.trim();
            const shippingCompany = document.getElementById('shippingCompany').value;
            
            console.log('🔍 입력값 확인:', {
                trackingNumber: trackingNumber,
                shippingCompany: shippingCompany,
                trackingNumberLength: trackingNumber.length
            });
            
            // 유효성 검사
            if (!trackingNumber) {
                console.log('❌ 추적번호가 비어있음');
                showError('配送追跡番号を入力してください。');
                return;
            }
            
            if (!shippingCompany) {
                showError('配送方法を選択してください。');
                return;
            }
            
            
            if (!window.FirebaseService || !window.FirebaseService.db) {
                console.error('❌ FirebaseService를 찾을 수 없습니다.');
                showError('Firebase 연결에 문제가 발생했습니다.');
                return;
            }
            
            const orderRef = window.FirebaseService.db.collection('orders').doc(orderId);
            
            orderRef.update({
                status: 'shipped',
                trackingNumber: trackingNumber,
                shippingCompany: shippingCompany,
                shippedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            })
            .then(() => {
                console.log('✅ 배송 정보 업데이트 완료:', orderId);
                
                // 로컬 주문 데이터 업데이트
                const orderIndex = allOrders.findIndex(o => o.id === orderId);
                if (orderIndex !== -1) {
                    allOrders[orderIndex].status = 'shipped';
                    allOrders[orderIndex].trackingNumber = trackingNumber;
                    allOrders[orderIndex].shippingCompany = shippingCompany;
                    allOrders[orderIndex].shippedAt = new Date().toISOString();
                    allOrders[orderIndex].updatedAt = new Date().toISOString();
                    
                    console.log('🔄 로컬 데이터 업데이트 완료:', allOrders[orderIndex]);
                }
                
                // 모달 닫기
                const modal = bootstrap.Modal.getInstance(document.getElementById('shippingModal'));
                modal.hide();
                
                // UI 즉시 업데이트 (완료 버튼 표시를 위해)
                console.log('🔄 UI 즉시 업데이트 시작');
                console.log('🔍 업데이트 전 주문 상태:', allOrders.find(o => o.id === orderId)?.status);
                
                updateOrderStatistics();
                displayOrders();
                
                console.log('🔍 업데이트 후 주문 상태:', allOrders.find(o => o.id === orderId)?.status);
                console.log('✅ UI 업데이트 완료 - 완료 버튼 표시됨');
                
                // 추가 확인: DOM에 완료 버튼이 있는지 체크
                setTimeout(() => {
                    const completeButton = document.querySelector(`button[onclick*="updateOrderStatus('${orderId}', 'completed')"]`);
                    if (completeButton) {
                        console.log('✅ 완료 버튼이 DOM에 존재함:', completeButton.textContent.trim());
                    } else {
                        console.log('❌ 완료 버튼이 DOM에 없음');
                    }
                }, 50);
                
                // 배송 시작 메일 발송 (비동기로 처리)
                setTimeout(() => {
                    console.log('📧 배송 시작 메일 발송 시작:', orderId);
                    sendShippingStartEmail(orderId, trackingNumber, shippingCompany);
                }, 200);
                
                showSuccess('配送情報が更新され、配送開始メールが送信されました。');
            })
            .catch((error) => {
                console.error('❌ 배송 정보 업데이트 실패:', error);
                showError('配送情報の更新に失敗しました。');
            });
        }

        // 배송 방법 한국어 변환 함수
        function getShippingMethodInJapanese(shippingMethod) {
            const shippingMethods = {
                'yamato': 'ヤマト運輸 (宅急便)',
                'yamato-cool': 'ヤマト運輸 (クール宅急便)',
                'yamato-takkyubin': 'ヤマト運輸 (タイム便)',
                'sagawa': '佐川急便 (飛脚宅配便)',
                'sagawa-cool': '佐川急便 (飛脚宅配便クール)',
                'japan-post-yu-pack': '日本郵便 (ゆうパック)',
                'japan-post-express': '日本郵便 (EMS)',
                'japan-post-registered': '日本郵便 (レターパック)',
                'kuroneko': 'クロネコヤマト',
                'other': 'その他'
            };
            return shippingMethods[shippingMethod] || shippingMethod;
        }

        // 배송 시작 메일 발송
        async function sendShippingStartEmail(orderId, trackingNumber, shippingCompany) {
            try {
                const order = allOrders.find(o => o.id === orderId);
                if (!order) return;
                
                console.log('배송 시작 메일 발송 시작:', orderId);
                console.log('📦 전달받은 값들:', {
                    trackingNumber: trackingNumber,
                    shippingCompany: shippingCompany
                });
                console.log('📦 주문 데이터 전체:', order);
                console.log('📦 주문 데이터 키들:', Object.keys(order));
                console.log('📦 주문 아이템들:', order.items);
                console.log('📦 주문 총액 필드들:', {
                    totalAmount: order.totalAmount,
                    total: order.total,
                    amount: order.amount,
                    subtotal: order.subtotal,
                    orderTotal: order.orderTotal
                });
                console.log('📦 배송 정보:', order.shipping);
                console.log('📦 배송 주소 정보:', order.shippingAddress);
                
                const response = await fetch('/.netlify/functions/send-email', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        to: order.customerEmail || order.userEmail,
                        subject: '配送開始のお知らせ - Aether Store',
                        type: 'shipping-start',
                        data: {
                            orderId: orderId,
                            name: order.customerName || order.userName || order.customerEmail?.split('@')[0] || 'お客様',
                            trackingNumber: trackingNumber,
                            shippingMethod: getShippingMethodInJapanese(shippingCompany),
                            // 실제 데이터 매핑 (더 포괄적인 구조 지원)
                            items: (() => {
                                console.log('🔍 아이템 데이터 확인:', {
                                    hasItems: !!order.items,
                                    itemsType: typeof order.items,
                                    itemsIsArray: Array.isArray(order.items),
                                    itemsLength: order.items?.length,
                                    items: order.items
                                });
                                
                                if (order.items && Array.isArray(order.items) && order.items.length > 0) {
                                    return order.items.map(item => {
                                        console.log('🔍 개별 아이템:', item);
                                        const productName = item.name || item.productName || item.title || item.product_name || item.product_title || item.product || '商品名不明';
                                        const brand = item.brand || item.productBrand || item.brandName || '';
                                        const quantity = item.quantity || item.qty || item.amount || item.count || 1;
                                        const result = brand ? `${brand} ${productName} (${quantity}個)` : `${productName} (${quantity}個)`;
                                        console.log('✅ 아이템 매핑 결과:', result);
                                        return result;
                                    }).join(', ');
                                } else {
                                    console.log('❌ 아이템 데이터 없음, 기본값 사용');
                                    return '商品情報なし';
                                }
                            })(),
                            totalAmount: (() => {
                                console.log('🔍 총액 데이터 확인:', {
                                    totalAmount: order.totalAmount,
                                    total: order.total,
                                    amount: order.amount,
                                    subtotal: order.subtotal,
                                    orderTotal: order.orderTotal,
                                    originalAmount: order.originalAmount
                                });
                                
                                const amount = order.totalAmount || order.total || order.amount || order.subtotal || order.orderTotal || order.originalAmount || 0;
                                const result = `¥${amount.toLocaleString()}`;
                                console.log('✅ 총액 매핑 결과:', result);
                                return result;
                            })(),
                            shippingAddress: (() => {
                                console.log('🔍 배송 주소 데이터 확인:', {
                                    hasShipping: !!order.shipping,
                                    hasShippingAddress: !!order.shippingAddress,
                                    shipping: order.shipping,
                                    shippingAddress: order.shippingAddress
                                });
                                
                                if (!order.shipping && !order.shippingAddress) {
                                    console.log('❌ 배송 정보 없음, 기본값 사용');
                                    return '配送先情報なし';
                                }
                                
                                const shipping = order.shipping || {};
                                const address = order.shippingAddress || {};
                                
                                console.log('🔍 배송 정보 키들:', Object.keys(shipping));
                                console.log('🔍 주소 정보 키들:', Object.keys(address));
                                
                                const postal = shipping.postal || shipping.postalCode || address.postal || address.postalCode || '';
                                const prefecture = shipping.prefecture || shipping.state || address.prefecture || address.state || '';
                                const city = shipping.city || address.city || '';
                                const address1 = shipping.address1 || shipping.address || address.address1 || address.address || '';
                                const address2 = shipping.address2 || address.address2 || '';
                                
                                const fullAddress = `${postal} ${prefecture} ${city} ${address1} ${address2}`.trim();
                                console.log('✅ 배송 주소 매핑 결과:', fullAddress);
                                return fullAddress || '配送先情報なし';
                            })()
                        }
                    })
                });
                
                // 메일 발송 전 매핑된 데이터 확인 (매개변수 사용)
                console.log('📧 매핑된 메일 데이터:', {
                    orderId: orderId,
                    name: order.customerName || order.userName || order.customerEmail?.split('@')[0] || 'お客様',
                    trackingNumber: trackingNumber,
                    shippingMethod: getShippingMethodInJapanese(shippingCompany),
                    items: order.items ? order.items.map(item => {
                        const productName = item.name || item.productName || item.title || item.product_name || item.product_title || item.product || '商品名不明';
                        const brand = item.brand || item.productBrand || item.brandName || '';
                        const quantity = item.quantity || item.qty || item.amount || item.count || 1;
                        return brand ? `${brand} ${productName} (${quantity}個)` : `${productName} (${quantity}個)`;
                    }).join(', ') : '商品情報なし',
                    totalAmount: (() => {
                        const amount = order.totalAmount || order.total || order.amount || order.subtotal || order.orderTotal || 0;
                        return `¥${amount.toLocaleString()}`;
                    })(),
                    shippingAddress: (() => {
                        if (!order.shipping && !order.shippingAddress) return '配送先情報なし';
                        
                        const shipping = order.shipping || {};
                        const address = order.shippingAddress || {};
                        
                        const postal = shipping.postal || shipping.postalCode || address.postal || address.postalCode || '';
                        const prefecture = shipping.prefecture || shipping.state || address.prefecture || address.state || '';
                        const city = shipping.city || address.city || '';
                        const address1 = shipping.address1 || shipping.address || address.address1 || address.address || '';
                        const address2 = shipping.address2 || address.address2 || '';
                        
                        const fullAddress = `${postal} ${prefecture} ${city} ${address1} ${address2}`.trim();
                        return fullAddress || '配送先情報なし';
                    })()
                });
                
                
                const result = await response.json();
                if (result.success) {
                    console.log('✅ 배송 시작 메일 발송 완료:', result);
                } else {
                    console.error('❌ 배송 시작 메일 발송 실패:', result.error);
                    showError('配送開始メールの送信に失敗しました: ' + (result.error || 'Unknown error'));
                }
                
            } catch (error) {
                console.error('❌ 배송 시작 메일 발송 오류:', error);
                showError('配送開始メールの送信に失敗しました: ' + error.message);
            }
        }
        
        // 주문 상세 보기
        function viewOrderDetail(orderId) {
            const order = allOrders.find(o => o.id === orderId);
            if (!order) {
                showError('注文情報が見つかりません。');
                return;
            }
            
            const modalContent = createOrderDetailHTML(order);
            document.getElementById('order-detail-content').innerHTML = modalContent;
            
            const modal = new bootstrap.Modal(document.getElementById('orderDetailModal'));
            modal.show();
        }
        
        // 주문 상세 HTML 생성
        function createOrderDetailHTML(order) {
            // 날짜 처리 - 여러 필드에서 날짜 찾기 (날짜 + 시간)
            let orderDate = '날짜 없음';
            if (order.orderDate) {
                const date = new Date(order.orderDate.seconds ? order.orderDate.seconds * 1000 : order.orderDate);
                if (!isNaN(date.getTime())) {
                    orderDate = date.toLocaleString('ja-JP');
                }
            } else if (order.createdAt) {
                const date = new Date(order.createdAt.seconds ? order.createdAt.seconds * 1000 : order.createdAt);
                if (!isNaN(date.getTime())) {
                    orderDate = date.toLocaleString('ja-JP');
                }
            }
            
            // 금액 정보 처리 (상세 모달용)
            const subtotal = order.subtotal || order.originalAmount || 0;
            const shippingFee = order.shippingFee || order.shipping?.shippingFee || 0;
            const usedPoints = order.usedPoints || order.pointDiscount || 0;
            const totalAmount = order.totalAmount || 0;
            
            // 고객 이름 처리 - shipping.name 우선, 여러 필드에서 이름 찾기
            let customerName = '不明';
            if (order.shipping && order.shipping.name && order.shipping.name !== 'null') {
                customerName = order.shipping.name;
            } else if (order.customer && order.customer.name && order.customer.name !== 'null') {
                customerName = order.customer.name;
            } else if (order.userName && order.userName !== 'null') {
                customerName = order.userName;
            } else if (order.customerName && order.customerName !== 'null') {
                customerName = order.customerName;
            }
            
            const customerEmail = order.customer ? order.customer.email : (order.customerEmail || order.userEmail || '不明');
            const customerPhone = order.shipping ? order.shipping.phone : (order.customer ? order.customer.phone : (order.customerPhone || '不明'));
            
            // 배송 주소 처리 (상세 모달용)
            let fullShippingAddress = '';
            if (order.shipping) {
                const parts = [];
                if (order.shipping.postal) parts.push(`〒${order.shipping.postal}`);
                if (order.shipping.prefecture) parts.push(order.shipping.prefecture);
                if (order.shipping.city) parts.push(order.shipping.city);
                if (order.shipping.address1) parts.push(order.shipping.address1);
                if (order.shipping.address2) parts.push(order.shipping.address2);
                fullShippingAddress = parts.join(' ');
            }
            
            // 결제 방법 처리
            let paymentMethod = '不明';
            if (order.paymentMethod) {
                paymentMethod = order.paymentMethod === 'card' ? 'カード' : 
                               order.paymentMethod === 'bank-transfer' ? '銀行振込' : order.paymentMethod;
            } else if (order.payment && order.payment.method) {
                paymentMethod = order.payment.method === 'card' ? 'カード' : 
                               order.payment.method === 'bank-transfer' ? '銀行振込' : order.payment.method;
            }
            
            let itemsHTML = '';
            if (order.items && order.items.length > 0) {
                itemsHTML = order.items.map(item => `
                    <tr>
                        <td>${item.name}</td>
                        <td class="text-center">${item.quantity}</td>
                        <td class="text-end">¥${item.price ? item.price.toLocaleString() : '0'}</td>
                        <td class="text-end">¥${(item.price * item.quantity).toLocaleString()}</td>
                    </tr>
                `).join('');
            }
            
            return `
                <div class="row">
                    <div class="col-md-6">
                        <h6 class="japanese-heading">注文情報</h6>
                        <table class="table table-sm">
                            <tr><td>注文番号:</td><td>${order.id}</td></tr>
                            <tr><td>注文日時:</td><td>${orderDate}</td></tr>
                            <tr><td>状態:</td><td><span class="order-status status-${order.status}">${getStatusText(order.status)}</span></td></tr>
                            <tr><td>商品金額:</td><td>¥${subtotal.toLocaleString()}</td></tr>
                            ${shippingFee > 0 ? `<tr><td>配送料:</td><td>¥${shippingFee.toLocaleString()}</td></tr>` : ''}
                            ${usedPoints > 0 ? `<tr><td>ポイント使用:</td><td>-¥${usedPoints.toLocaleString()}</td></tr>` : ''}
                            <tr><td>合計金額:</td><td class="fw-bold">¥${totalAmount.toLocaleString()}</td></tr>
                            <tr><td>支払い方法:</td><td>${paymentMethod}</td></tr>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <h6 class="japanese-heading">顧客情報</h6>
                        <table class="table table-sm">
                            <tr><td>名前:</td><td>${customerName}</td></tr>
                            <tr><td>メール:</td><td>${customerEmail}</td></tr>
                            <tr><td>電話:</td><td>${customerPhone}</td></tr>
                            ${fullShippingAddress ? `<tr><td>配送先:</td><td>${fullShippingAddress}</td></tr>` : ''}
                        </table>
                    </div>
                </div>
                
                <div class="mt-4">
                    <h6 class="japanese-heading">注文商品</h6>
                    <div class="table-responsive">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>商品名</th>
                                    <th class="text-center">数量</th>
                                    <th class="text-end">単価</th>
                                    <th class="text-end">小計</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${itemsHTML}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        // 필터링 함수들
        function filterOrders() {
            const statusFilter = document.getElementById('status-filter').value;
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            
            console.log('🔍 필터링 시작 (상태 및 검색어만):', { statusFilter, searchTerm });
            console.log('📊 전체 주문 수:', allOrders.length);
            
            filteredOrders = allOrders.filter(order => {
                // 상태 필터
                if (statusFilter) {
                    if (statusFilter === 'pending') {
                        // pending 필터는 pending과 pending_payment 모두 포함
                        if (order.status !== 'pending' && order.status !== 'pending_payment') {
                            return false;
                        }
                    } else if (order.status !== statusFilter) {
                        return false;
                    }
                }
                
                // 검색 필터
                if (searchTerm) {
                    const searchableText = `${order.id} ${order.customer ? order.customer.name : ''} ${order.customer ? order.customer.email : ''}`.toLowerCase();
                    if (!searchableText.includes(searchTerm)) return false;
                }
                
                return true;
            });
            
            console.log('✅ 필터링 완료:', filteredOrders.length, '개 주문 표시');
            displayOrders();
        }
        
        function searchOrders() {
            filterOrders();
        }
        
        function clearSearch() {
            document.getElementById('search-input').value = '';
            filterOrders();
        }
        
        function clearAllFilters() {
            // 모든 통계 카드에서 active 클래스 제거
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active');
            });
            
            // 필터 초기화
            document.getElementById('status-filter').value = '';
            document.getElementById('date-filter').value = 'today';
            document.getElementById('search-input').value = '';
            
            // 날짜를 오늘로 초기화
            currentDate = new Date();
            
            // 날짜 네비게이션 표시
            document.querySelector('.date-navigation').style.display = 'block';
            
            updateDateDisplay();
            
            // 기존 주문 데이터에 오늘 날짜 필터 적용
            console.log('🔄 리셋으로 인한 재필터링 (오늘 날짜)');
            if (allOrders.length > 0) {
                applyDateFilter(allOrders, 'today');
            } else {
                // 주문 데이터가 없으면 다시 로드
                loadOrders();
            }
        }
        
        function refreshOrders() {
            loadOrders();
        }
        
        // CSV 다운로드 함수
        function downloadCSV() {
            try {
                console.log('📊 CSV 다운로드 시작');
                
                // 현재 필터링된 주문 데이터 사용
                const ordersToExport = filteredOrders.length > 0 ? filteredOrders : allOrders;
                
                if (ordersToExport.length === 0) {
                    alert('エクスポートする注文データがありません。');
                    return;
                }
                
                // CSV 헤더 정의
                const headers = [
                    '注文番号',
                    '注文日時',
                    '顧客名',
                    'メールアドレス',
                    '電話番号',
                    '配送先住所',
                    '注文状態',
                    '支払い方法',
                    '商品金額',
                    '配送料',
                    'ポイント使用',
                    '合計金額',
                    '商品詳細'
                ];
                
                // CSV 데이터 생성
                const csvData = ordersToExport.map(order => {
                    // 날짜 처리
                    let orderDate = '';
                    if (order.orderDate) {
                        const date = new Date(order.orderDate.seconds ? order.orderDate.seconds * 1000 : order.orderDate);
                        if (!isNaN(date.getTime())) {
                            orderDate = date.toLocaleString('ja-JP');
                        }
                    } else if (order.createdAt) {
                        const date = new Date(order.createdAt.seconds ? order.createdAt.seconds * 1000 : order.createdAt);
                        if (!isNaN(date.getTime())) {
                            orderDate = date.toLocaleString('ja-JP');
                        }
                    }
                    
                    // 고객 이름 처리
                    let customerName = '';
                    if (order.shipping && order.shipping.name && order.shipping.name !== 'null') {
                        customerName = order.shipping.name;
                    } else if (order.customer && order.customer.name && order.customer.name !== 'null') {
                        customerName = order.customer.name;
                    } else if (order.userName && order.userName !== 'null') {
                        customerName = order.userName;
                    } else if (order.customerName && order.customerName !== 'null') {
                        customerName = order.customerName;
                    }
                    
                    // 이메일 처리
                    const customerEmail = order.customer ? order.customer.email : (order.customerEmail || order.userEmail || '');
                    
                    // 전화번호 처리
                    const customerPhone = order.shipping ? order.shipping.phone : (order.customer ? order.customer.phone : (order.customerPhone || ''));
                    
                    // 배송 주소 처리
                    let shippingAddress = '';
                    if (order.shipping) {
                        const parts = [];
                        if (order.shipping.postal) parts.push(order.shipping.postal);
                        if (order.shipping.prefecture) parts.push(order.shipping.prefecture);
                        if (order.shipping.city) parts.push(order.shipping.city);
                        if (order.shipping.address1) parts.push(order.shipping.address1);
                        if (order.shipping.address2) parts.push(order.shipping.address2);
                        shippingAddress = parts.join(' ');
                    }
                    
                    // 주문 상태 처리
                    const orderStatus = getStatusText(order.status);
                    
                    // 결제 방법 처리
                    let paymentMethod = '';
                    if (order.paymentMethod) {
                        paymentMethod = order.paymentMethod === 'card' ? 'カード' : '銀行振込';
                    } else if (order.payment && order.payment.method) {
                        paymentMethod = order.payment.method === 'card' ? 'カード' : '銀行振込';
                    }
                    
                    // 금액 정보 처리
                    const subtotal = order.subtotal || order.originalAmount || 0;
                    const shippingFee = order.shippingFee || order.shipping?.shippingFee || 0;
                    const usedPoints = order.usedPoints || order.pointDiscount || 0;
                    const totalAmount = order.totalAmount || 0;
                    
                    // 상품 상세 정보 처리
                    let productDetails = '';
                    if (order.items && order.items.length > 0) {
                        productDetails = order.items.map(item => {
                            const quantity = item.quantity || 1;
                            const price = item.price || 0;
                            return `${item.name || item.productName || '商品'} x${quantity} (¥${price.toLocaleString()})`;
                        }).join('; ');
                    }
                    
                    return [
                        order.id || '',
                        orderDate,
                        customerName,
                        customerEmail,
                        customerPhone,
                        shippingAddress,
                        orderStatus,
                        paymentMethod,
                        subtotal.toLocaleString(),
                        shippingFee.toLocaleString(),
                        usedPoints.toLocaleString(),
                        totalAmount.toLocaleString(),
                        productDetails
                    ];
                });
                
                // CSV 문자열 생성
                const csvContent = [
                    headers.join(','),
                    ...csvData.map(row => 
                        row.map(field => {
                            // 필드에 쉼표나 따옴표가 있으면 따옴표로 감싸기
                            const fieldStr = String(field || '');
                            if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
                                return `"${fieldStr.replace(/"/g, '""')}"`;
                            }
                            return fieldStr;
                        }).join(',')
                    )
                ].join('\n');
                
                // BOM 추가 (Excel에서 한글 깨짐 방지)
                const BOM = '\uFEFF';
                const csvWithBOM = BOM + csvContent;
                
                // 파일명 생성 (현재 날짜와 필터 정보 포함)
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const statusFilter = document.getElementById('status-filter').value;
                const dateFilter = document.getElementById('date-filter').value;
                
                let fileName = `注文データ_${dateStr}`;
                if (statusFilter) {
                    const statusText = getStatusText(statusFilter);
                    fileName += `_${statusText}`;
                }
                if (dateFilter !== 'all') {
                    fileName += `_${dateFilter}`;
                }
                fileName += '.csv';
                
                // 파일 다운로드
                const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`✅ CSV 다운로드 완료: ${fileName} (${ordersToExport.length}건)`);
                
                // 성공 메시지 표시
                showToast('CSVファイルをダウンロードしました', 'success', 3000);
                
            } catch (error) {
                console.error('❌ CSV 다운로드 실패:', error);
                alert('CSVダウンロード中にエラーが発生しました。');
            }
        }
        
        // 토스트 메시지 표시 함수
        function showToast(message, type = 'info', duration = 3000) {
            // 기존 토스트 제거
            const existingToast = document.querySelector('.custom-toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // 토스트 생성
            const toast = document.createElement('div');
            toast.className = 'custom-toast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 9999;
                background: #f8f9fa;
                border: 1px solid #6c757d;
                border-radius: 8px;
                padding: 12px 16px;
                color: #343a40;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                font-size: 14px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                animation: slideInRight 0.3s ease-out;
            `;
            
            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <i class="fas fa-check-circle" style="color: #28a745;"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // 자동 제거
            setTimeout(() => {
                if (toast && toast.parentNode) {
                    toast.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (toast && toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, duration);
        }
        
        function exportOrders() {
            // CSV 내보내기 기능 (향후 구현)
            showInfo('エクスポート機能は準備中です。');
        }
        
        function printOrder() {
            window.print();
        }
        
        // 이메일 알림 발송
        async function sendOrderStatusNotification(orderId, newStatus, cancelReason = null) {
            try {
                console.log('📧 이메일 알림 발송 시작:', orderId, newStatus);
                
                // 주문 데이터 가져오기
                const orderData = allOrders.find(order => order.id === orderId);
                
                // 디버깅: 주문 데이터 확인
                console.log('🔍 주문 데이터 확인:', {
                    orderId: orderId,
                    orderData: orderData,
                    pointsUsed: orderData?.pointsUsed,
                    pointsEarned: orderData?.pointsEarned,
                    totalAmount: orderData?.totalAmount,
                    subtotal: orderData?.subtotal,
                    allFields: Object.keys(orderData || {})
                });
                
                if (!orderData) {
                    console.error('주문 데이터를 찾을 수 없습니다:', orderId);
                    return;
                }
                
                // 취소 상태일 때 포인트 환불 및 취소 메일 발송
                if (newStatus === 'cancelled') {
                    const actualCancelReason = cancelReason || '管理者によるキャンセル';
                    
                    // 포인트 처리 순서: 1) 사용 포인트 반환, 2) 지급 포인트 회수
                    let refundedPoints = 0;
                    
                    // 포인트 사용량 확인 (다양한 필드명 지원)
                    const pointsUsed = orderData.usedPoints || orderData.pointsUsed || orderData.points_used || orderData.points || 0;
                    console.log('🔍 포인트 사용량 확인:', {
                        pointsUsed: pointsUsed,
                        orderDataPointsUsed: orderData.pointsUsed,
                        orderDataUsedPoints: orderData.usedPoints,
                        orderDataPoints_used: orderData.points_used,
                        orderDataPoints: orderData.points,
                        orderDataKeys: Object.keys(orderData)
                    });
                    
                    if (pointsUsed > 0) {
                        try {
                            console.log('💰 ポイント返還開始:', pointsUsed);
                            refundedPoints = pointsUsed;
                            
                            // ユーザーポイント復元
                            const userRef = window.FirebaseService.db.collection('users').doc(orderData.userEmail);
                            await window.FirebaseService.db.runTransaction(async (transaction) => {
                                const userDoc = await transaction.get(userRef);
                                console.log('🔍 사용자 문서 확인:', {
                                    userEmail: orderData.userEmail,
                                    userDocExists: userDoc.exists,
                                    currentPoints: userDoc.exists ? userDoc.data().points : 'N/A'
                                });
                                if (userDoc.exists) {
                                    const currentPoints = userDoc.data().points || 0;
                                    const newPoints = currentPoints + refundedPoints;
                                    
                                    // ポイント復元
                                    transaction.update(userRef, {
                                        points: newPoints
                                    });
                                    
                                    console.log('✅ ポイント返還完了:', refundedPoints);
                                    
                                    // ポイント返還 히스토리 추가
                                    const pointHistoryRef = window.FirebaseService.db.collection('pointHistory').doc();
                                    transaction.set(pointHistoryRef, {
                                        userId: orderData.userId,
                                        userEmail: orderData.userEmail,
                                        points: refundedPoints,
                                        type: 'refund',
                                        reason: `注文キャンセル - ${orderId} ポイント返還`,
                                        balance: newPoints,
                                        orderId: orderId,
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                                    });
                                    
                                    console.log('✅ ポイント返還 히스토리 추가 완료:', refundedPoints);
                                } else {
                                    console.error('❌ 사용자 문서를 찾을 수 없습니다:', orderData.userEmail);
                                    throw new Error(`사용자 문서가 존재하지 않습니다: ${orderData.userEmail}`);
                                }
                            });
                        } catch (error) {
                            console.error('❌ ポイント返還失敗:', error);
                        }
                    } else {
                        console.log('ℹ️ 使用ポイントなし、返還不要');
                    }
                    
                    // 포인트 반환과 회수 사이에 시간 간격 추가 (순서 보장)
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // 구매 시 지급된 포인트 회수 처리
                    let earnedPointsToDeduct = 0;
                    
                    // 포인트 히스토리에서 실제 지급된 포인트 조회 (완전히 새로운 로직)
                    let earnedPoints = 0;
                    
                    try {
                        console.log('🔍 포인트 히스토리에서 구매 시 지급된 포인트 조회 시작:', orderId);
                        console.log('🔍 주문 데이터 전체:', orderData);
                        
                        // 포인트 히스토리에서 해당 주문의 모든 포인트 조회
                        // orderBy 제거 - Firebase 인덱스 없이도 작동하도록 (클라이언트 측 정렬)
                        const pointHistorySnapshot = await window.FirebaseService.db
                            .collection('pointHistory')
                            .where('orderId', '==', orderId)
                            .get();
                        
                        console.log('📊 포인트 히스토리 총 개수:', pointHistorySnapshot.size);
                        
                        if (!pointHistorySnapshot.empty) {
                            let earnedPointsFromHistory = 0;
                            let allPointEntries = [];
                            
                            // 모든 포인트 히스토리 항목을 상세히 로그
                            pointHistorySnapshot.forEach(doc => {
                                const pointData = doc.data();
                                const entry = {
                                    id: doc.id,
                                    points: pointData.points || 0,
                                    reason: pointData.reason || '',
                                    type: pointData.type || '',
                                    createdAt: pointData.createdAt,
                                    userId: pointData.userId,
                                    userEmail: pointData.userEmail,
                                    balance: pointData.balance
                                };
                                allPointEntries.push(entry);
                                
                                console.log('📊 포인트 히스토리 상세 항목:', entry);
                            });
                            
                            // createdAt을 Date로 변환하고 최신순으로 정렬
                            allPointEntries.forEach(entry => {
                                if (entry.createdAt && entry.createdAt.seconds) {
                                    entry.createdAtDate = new Date(entry.createdAt.seconds * 1000);
                                } else if (entry.createdAt && entry.createdAt.toDate) {
                                    entry.createdAtDate = entry.createdAt.toDate();
                                } else if (entry.createdAt) {
                                    entry.createdAtDate = new Date(entry.createdAt);
                                } else {
                                    entry.createdAtDate = new Date(0);
                                }
                            });
                            
                            // 최신순으로 정렬
                            allPointEntries.sort((a, b) => b.createdAtDate.getTime() - a.createdAtDate.getTime());
                            
                            console.log('📊 정렬된 포인트 히스토리 (최신순):', allPointEntries.length, '건');
                            
                            // 디버깅: 모든 포인트 히스토리 항목 상세 출력
                            allPointEntries.forEach((entry, index) => {
                                console.log(`📊 항목 ${index + 1}:`, {
                                    points: entry.points,
                                    reason: entry.reason,
                                    type: entry.type,
                                    createdAt: entry.createdAtDate?.toLocaleString('ja-JP'),
                                    id: entry.id
                                });
                            });
                            
                            // 가장 정확한 구매 시 지급된 포인트 찾기 (우선순위 기반)
                            let foundPoints = false;
                            
                            // 모든 포인트 히스토리에서 '商品購入' 관련 항목들을 분류
                            let purchaseEarnedEntries = [];
                            let purchaseUsedEntries = [];
                            let otherEarnedEntries = [];
                            
                            allPointEntries.forEach(entry => {
                                if (entry.reason === '商品購入' && entry.points > 0) {
                                    purchaseEarnedEntries.push(entry);
                                    console.log('✅ 구매 시 지급된 포인트 항목 발견:', {
                                        points: entry.points,
                                        type: entry.type,
                                        reason: entry.reason,
                                        createdAt: entry.createdAtDate?.toLocaleString('ja-JP')
                                    });
                                } else if (entry.reason === '商品購入に使用' && entry.points > 0) {
                                    purchaseUsedEntries.push(entry);
                                    console.log('❌ 구매 시 사용된 포인트 항목 (제외):', {
                                        points: entry.points,
                                        type: entry.type,
                                        reason: entry.reason,
                                        createdAt: entry.createdAtDate?.toLocaleString('ja-JP')
                                    });
                                } else if (entry.type === 'earn' && entry.points > 0) {
                                    otherEarnedEntries.push(entry);
                                    console.log('ℹ️ 기타 지급된 포인트 항목:', {
                                        points: entry.points,
                                        type: entry.type,
                                        reason: entry.reason,
                                        createdAt: entry.createdAtDate?.toLocaleString('ja-JP')
                                    });
                                }
                            });
                            
                            console.log('📊 포인트 히스토리 분류 결과:', {
                                구매시지급: purchaseEarnedEntries.length,
                                구매시사용: purchaseUsedEntries.length,
                                기타지급: otherEarnedEntries.length
                            });
                            
                            // 우선순위 1: 정확한 '商品購入' 항목 (type='earn' 또는 'earned')
                            for (let entry of purchaseEarnedEntries) {
                                if (entry.type === 'earn' || entry.type === 'earned') {
                                    earnedPointsFromHistory = entry.points;
                                    console.log('✅ 우선순위1 - 정확한 매칭 (reason=商品購入, type=earn/earned):', earnedPointsFromHistory);
                                    foundPoints = true;
                                    break;
                                }
                            }
                            
                            // 우선순위 2: '商品購入' 항목 중 양수 (type 무관하지만 '商品購入に使用' 제외)
                            if (!foundPoints && purchaseEarnedEntries.length > 0) {
                                for (let entry of purchaseEarnedEntries) {
                                    // '商品購入に使用'가 아닌 '商品購入' 항목만 선택
                                    if (entry.reason === '商品購入' && !entry.reason.includes('使用')) {
                                        earnedPointsFromHistory = entry.points;
                                        console.log('✅ 우선순위2 - reason=商品購入 (사용 제외):', earnedPointsFromHistory);
                                        foundPoints = true;
                                        break;
                                    }
                                }
                            }
                            
                            // 우선순위 3: 배송 완료 시점의 포인트 적립 항목
                            if (!foundPoints) {
                                for (let entry of otherEarnedEntries) {
                                    if (entry.reason && entry.reason.includes('배송 완료') && entry.reason.includes('포인트 적립')) {
                                        earnedPointsFromHistory = entry.points;
                                        console.log('✅ 우선순위3 - 배송 완료 시점 포인트 적립:', earnedPointsFromHistory);
                                        foundPoints = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (earnedPointsFromHistory > 0) {
                                earnedPoints = earnedPointsFromHistory;
                                console.log('✅ 최종 선택된 구매 시 지급된 포인트:', earnedPoints);
                                console.log('🔍 포인트 차감 검증:', {
                                    차감할포인트: earnedPoints,
                                    주문ID: orderId,
                                    사용자이메일: orderData.userEmail || orderData.customerEmail
                                });
                            } else {
                                console.log('⚠️ 모든 조건에서 지급된 포인트를 찾을 수 없음');
                                console.log('🔄 폴백: 배송 완료 시점의 실제 지급 포인트 조회');
                                
                                // 배송 완료 시점의 실제 지급 포인트를 조회
                                try {
                                    console.log('🔍 배송 완료 시점의 포인트 히스토리 조회 중...');
                                    const deliveryPointSnapshot = await window.FirebaseService.db
                                        .collection('pointHistory')
                                        .where('orderId', '==', orderId)
                                        .where('reason', '==', '배송 완료 - 주문 ' + orderId + ' 포인트 적립')
                                        .get();
                                    
                                    if (!deliveryPointSnapshot.empty) {
                                        deliveryPointSnapshot.forEach(doc => {
                                            const data = doc.data();
                                            if (data.points > 0) {
                                                earnedPoints = data.points;
                                                console.log('✅ 배송 완료 시점의 실제 지급 포인트 발견:', earnedPoints);
                                            }
                                        });
                                    }
                                } catch (error) {
                                    console.error('❌ 배송 완료 포인트 조회 실패:', error);
                                }
                                
                                // 여전히 찾지 못한 경우 주문 데이터에서 조회 (하지만 정확하지 않을 수 있음)
                                if (earnedPoints === 0) {
                                    console.log('🔄 최종 폴백: 주문 데이터에서 직접 조회');
                                    console.log('⚠️ 주문 데이터의 포인트는 정확하지 않을 수 있으므로 신중하게 검토 필요');
                                    
                                    // 주문 데이터에서 포인트 관련 필드들을 모두 확인
                                    const possibleEarnedPoints = orderData.earnedPoints || orderData.pointsEarned || orderData.points || 0;
                                    const possibleUsedPoints = orderData.pointsUsed || orderData.points_used || 0;
                                    
                                    console.log('🔍 주문 데이터 포인트 분석:', {
                                        earnedPoints: orderData.earnedPoints,
                                        pointsEarned: orderData.pointsEarned,
                                        points: orderData.points,
                                        pointsUsed: orderData.pointsUsed,
                                        points_used: orderData.points_used,
                                        possibleEarnedPoints: possibleEarnedPoints,
                                        possibleUsedPoints: possibleUsedPoints
                                    });
                                    
                                    // 지급된 포인트가 사용된 포인트보다 작거나 같으면 의심스러움
                                    if (possibleEarnedPoints > 0 && possibleEarnedPoints <= possibleUsedPoints) {
                                        console.log('⚠️ 의심스러운 포인트 값: 지급된 포인트가 사용된 포인트보다 작거나 같음');
                                        console.log('⚠️ 포인트 회수를 건너뛰고 관리자 확인 필요');
                                        earnedPoints = 0; // 회수하지 않음
                                    } else {
                                        earnedPoints = possibleEarnedPoints;
                                    }
                                    
                                    console.log('🔄 최종 폴백 결과:', earnedPoints);
                                }
                                
                                console.log('⚠️ 최종 조회된 포인트:', {
                                    earnedPoints: earnedPoints,
                                    orderDataEarnedPoints: orderData.earnedPoints,
                                    pointsEarned: orderData.pointsEarned,
                                    points: orderData.points
                                });
                            }
                        } else {
                            console.log('⚠️ 포인트 히스토리가 비어있음');
                            earnedPoints = orderData.earnedPoints || orderData.pointsEarned || orderData.points || 0;
                            console.log('🔄 주문 데이터에서 포인트 조회:', earnedPoints);
                        }
                    } catch (error) {
                        console.error('❌ 포인트 히스토리 조회 실패:', error);
                        earnedPoints = orderData.earnedPoints || orderData.pointsEarned || orderData.points || 0;
                        console.log('🔄 에러 시 폴백: 주문 데이터에서 포인트 조회:', earnedPoints);
                    }
                    
                    const pointsEarnedStatus = orderData.pointsEarnedStatus || 'not_earned';
                    
                    console.log('🔍 구매 시 지급된 포인트 확인:', {
                        earnedPoints: earnedPoints,
                        pointsEarnedStatus: pointsEarnedStatus,
                        orderDataEarnedPoints: orderData.earnedPoints,
                        orderDataPointsEarned: orderData.pointsEarned,
                        orderDataPoints_earned: orderData.points_earned,
                        orderDataKeys: Object.keys(orderData),
                        orderDataFull: orderData
                    });
                    
                    // 이미 지급된 포인트가 있는 경우 회수
                    // earnedPoints가 0보다 크면 회수 시도 (상태와 관계없이)
                    if (earnedPoints > 0) {
                        try {
                            console.log('💸 구매 시 지급된 포인트 회수 시작:', {
                                차감할포인트: earnedPoints,
                                주문ID: orderId,
                                주문상태: orderData.status,
                                포인트지급상태: orderData.pointsEarnedStatus
                            });
                            earnedPointsToDeduct = earnedPoints;
                            
                            // 사용자 포인트에서 차감
                            const userRef = window.FirebaseService.db.collection('users').doc(orderData.userEmail);
                            await window.FirebaseService.db.runTransaction(async (transaction) => {
                                const userDoc = await transaction.get(userRef);
                                console.log('🔍 포인트 회수 - 사용자 문서 확인:', {
                                    userEmail: orderData.userEmail,
                                    userDocExists: userDoc.exists,
                                    currentPoints: userDoc.exists ? userDoc.data().points : 'N/A',
                                    pointsToDeduct: earnedPointsToDeduct
                                });
                                
                                if (userDoc.exists) {
                                    const currentPoints = userDoc.data().points || 0;
                                    const newPoints = Math.max(0, currentPoints - earnedPointsToDeduct); // 0 이하로 내려가지 않도록
                                    
                                    // 포인트 차감
                                    transaction.update(userRef, {
                                        points: newPoints
                                    });
                                    
                                    console.log('✅ 구매 시 지급된 포인트 회수 완료:', {
                                        차감된포인트: earnedPointsToDeduct,
                                        회수전포인트: currentPoints,
                                        회수후포인트: newPoints,
                                        주문ID: orderId,
                                        사용자이메일: orderData.userEmail
                                    });
                                    
                                    // 포인트 회수 히스토리 추가
                                    const pointHistoryRef = window.FirebaseService.db.collection('pointHistory').doc();
                                    const pointHistoryData = {
                                        userId: orderData.userId,
                                        userEmail: orderData.userEmail,
                                        points: -earnedPointsToDeduct, // 음수로 기록
                                        type: 'deduction',
                                        reason: `注文キャンセル - ${orderId} ポイント返還`,
                                        balance: newPoints,
                                        orderId: orderId,
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                                    };
                                    
                                    transaction.set(pointHistoryRef, pointHistoryData);
                                    
                                    console.log('✅ 포인트 회수 히스토리 추가 완료:', {
                                        차감된포인트: -earnedPointsToDeduct,
                                        히스토리데이터: pointHistoryData,
                                        주문ID: orderId
                                    });
                                } else {
                                    console.error('❌ 포인트 회수 - 사용자 문서를 찾을 수 없습니다:', orderData.userEmail);
                                    throw new Error(`사용자 문서가 존재하지 않습니다: ${orderData.userEmail}`);
                                }
                            });
                        } catch (error) {
                            console.error('❌ 구매 시 지급된 포인트 회수 실패:', {
                                error: error,
                                errorMessage: error.message,
                                차감시도포인트: earnedPointsToDeduct,
                                주문ID: orderId,
                                사용자이메일: orderData.userEmail
                            });
                        }
                    } else {
                        console.log('ℹ️ 구매 시 지급된 포인트 없음 또는 미지급 상태, 회수 불필요:', {
                            조회된포인트: earnedPoints,
                            주문ID: orderId,
                            주문상태: orderData.status,
                            포인트지급상태: orderData.pointsEarnedStatus
                        });
                    }
                    
                    // キャンセルメール送信 (詳細情報含む)
                    try {
                        console.log('📧 注文キャンセルメール送信開始:', orderId);
                        
                        // 商品情報フォーマット
                        const itemsList = orderData.items ? orderData.items.map(item => 
                            `${item.name} (${item.quantity}個) - ¥${item.price.toLocaleString()}`
                        ).join('<br>') : '商品情報なし';
                        
                        const response = await fetch('/.netlify/functions/send-email', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                to: orderData.userEmail,
                                subject: '注文キャンセルのお知らせ - Aether Store',
                                type: 'order-cancelled',
                                data: {
                                    customerName: orderData.userName || orderData.customerName || 'お客様',
                                    orderId: orderData.id,
                                    cancelDate: new Date().toLocaleDateString('ja-JP'),
                                    cancelReason: actualCancelReason,
                                    paymentMethod: getPaymentMethodInJapanese(orderData.paymentMethod),
                                    items: itemsList,
                                    subtotal: `¥${orderData.subtotal?.toLocaleString() || '0'}`,
                                    shipping: getFormattedShipping(orderData.shipping),
                                    pointsUsed: `${pointsUsed}ポイント`,
                                    totalAmount: `¥${orderData.totalAmount?.toLocaleString() || '0'}`,
                                    refundedPoints: `${refundedPoints}ポイント`,
                                    deductedPoints: `${earnedPointsToDeduct}ポイント`
                                }
                            })
                        });
                        
                        const result = await response.json();
                        if (result.success) {
                            console.log('✅ 注文キャンセルメール送信完了:', orderId);
                        } else {
                            console.error('❌ 注文キャンセルメール送信失敗:', result.error);
                        }
                    } catch (error) {
                        console.error('❌ 注文キャンセルメール送信中エラー:', error);
                    }
                }
                
            } catch (error) {
                console.error('❌ メール通知送信エラー:', error);
            }
        }
        
        // 지불 방법을 일본어로 변환하는 함수
        function getPaymentMethodInJapanese(paymentMethod) {
            const paymentMethods = {
                'card': 'クレジットカード',
                'bank-transfer': '銀行振込',
                'bank_transfer': '銀行振込',
                'cash': '現金',
                'paypal': 'PayPal',
                'stripe': 'Stripe決済'
            };
            return paymentMethods[paymentMethod] || '銀行振込';
        }
        
        // 송료를 올바르게 포맷팅하는 함수
        function getFormattedShipping(shipping) {
            if (!shipping) return '¥0';
            
            // 숫자인 경우
            if (typeof shipping === 'number') {
                return `¥${shipping.toLocaleString()}`;
            }
            
            // 문자열인 경우
            if (typeof shipping === 'string') {
                // 이미 ¥가 포함되어 있는지 확인
                if (shipping.includes('¥')) {
                    return shipping;
                }
                // 숫자로 변환 가능한지 확인
                const numValue = parseFloat(shipping);
                if (!isNaN(numValue)) {
                    return `¥${numValue.toLocaleString()}`;
                }
                return shipping;
            }
            
            // 객체인 경우 (예: {amount: 500, currency: 'JPY'})
            if (typeof shipping === 'object' && shipping !== null) {
                if (shipping.amount !== undefined) {
                    return `¥${shipping.amount.toLocaleString()}`;
                }
                if (shipping.price !== undefined) {
                    return `¥${shipping.price.toLocaleString()}`;
                }
                if (shipping.value !== undefined) {
                    return `¥${shipping.value.toLocaleString()}`;
                }
            }
            
            // 기본값
            return '¥0';
        }
        
        // 유틸리티 함수들
        function showSuccess(message) {
            // 성공 메시지 표시 (향후 구현)
            console.log('✅', message);
        }
        
        function showError(message) {
            // 에러 메시지 표시 (향후 구현)
            console.error('❌', message);
        }
        
        function showInfo(message) {
            // 정보 메시지 표시 (향후 구현)
            console.log('ℹ️', message);
        }
        
        // 초기 필터링 적용 (제거 - loadOrders에서 처리)
    </script>
</body>
</html>
